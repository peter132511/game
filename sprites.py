import pygame, random, attacks
from extramath import sign
from pygameextras import load_image, play_sound, draw_text, split


# module containing all sprite definitions


# all-purpose function that does nothing
def do_nothing(*args):
    pass


# a bullet generated by an enemy at (x,y) that will harm the player
# moves itself according to initial velocity and acceleration, in pixels/tick
class EnemyBullet(pygame.sprite.Sprite):
    def __init__(self, groups, x, y, speedx, speedy,
                 image, accelx=0, accely=0):
        pygame.sprite.Sprite.__init__(self)
        self.groups = groups
        self.speedx = speedx
        self.speedy = speedy
        self.image = image
        self.accelx = accelx
        self.accely = accely
        self.rect = self.image.get_rect()
        self.radius = self.rect.width / 2
        self.rect.center = (x, y)
        self.pos = (x, y)
        self.add(groups.allSprites, groups.enemyBullets, groups.moveableSprites)

    def shift(self, amount):
        self.pos = (self.pos[0] + amount, self.pos[1])

    # method called every tick to move itself
    def update(self):
        self.pos = (self.pos[0] + self.speedx, self.pos[1] + self.speedy)
        self.rect.center = self.pos
        self.speedx += self.accelx
        self.speedy += self.accely

        # delete itself if sufficiently far off the screen
        if not (self.rect.left >= -600 and self.rect.right <= 1500):
            self.kill()


# a stationary circle which kills enemy bullets
class Shield(pygame.sprite.Sprite):
    def __init__(self, groups, assets):
        pygame.sprite.Sprite.__init__(self)
        self.lifespan = 60  # how long the shield lasts, in ticks
        self.groups = groups
        self.image = assets.shield
        groups.koishi.sprite.shielded = True
        self.rect = self.image.get_rect()
        self.rect.center = self.groups.koishi.sprite.rect.center
        self.radius = self.rect.width / 2  # for circle collision detection
        self.add(groups.allSprites, groups.shields)

    def update(self):
        self.rect.center = self.groups.koishi.sprite.rect.center
        pygame.sprite.spritecollide(self, self.groups.enemyBullets, True, pygame.sprite.collide_circle)
        self.lifespan -= 1
        if self.lifespan <= 0:  # kill self when expired
            self.groups.koishi.sprite.shielded = False
            self.kill()


# bullets fired by the player, that can damage enemies
class KoishiBullet(pygame.sprite.Sprite):
    def __init__(self, groups, assets):
        pygame.sprite.Sprite.__init__(self)
        self.dir = groups.koishi.sprite.dir
        self.lifespan = 60
        self.groups = groups
        if self.dir == "l":  # fetching images...
            self.image = assets.heartl
        else:
            self.image = assets.heartr
        self.rect = self.image.get_rect()
        self.rect.center = groups.koishi.sprite.rect.center
        self.add(groups.koishiBullets, groups.onScreenAll, groups.moveableSprites, groups.allSprites)

    def update(self):
        if self.dir == "l":
            self.rect.x -= 6
        else:
            self.rect.x += 6
        self.lifespan -= 1
        if self.lifespan <= 0:
            self.kill()


# the player sprite, Koishi
class Koishi(pygame.sprite.Sprite):
    def __init__(self, groups):
        pygame.sprite.Sprite.__init__(self)
        self.groups = groups
        self.dead = ""  # string containing the level end code
        self.shielded = False
        self.hp = 6
        self.jumpboost = 1
        self.yvel = 0  # falling speed
        self.platform = None  # if stood on a platform
        self.score = 0  # collected coins

        # the sprite when stationary
        self.fimages = [load_image("media/koishi/f0.png")] * 4
        self.image = self.fimages[0]
        self.images = self.fimages
        self.rect = self.image.get_rect()
        self.rect.midbottom = (450, 570)

        # the sprite when moving in the specified direction l/r, as a list of frames
        self.limages = [load_image("media/koishi/l" + str(x) + ".png") for x in range(4)]
        self.rimages = [pygame.transform.flip(im, True, False) for im in self.limages]

        # tracks current frame of sprite animation
        self.imCounter = 0

        # fire rate limiter
        self.fireCountdown = 0

        # shield rate limiter
        self.shieldCountdown = 0

        # tracks direction of travel as str ("l"/"r")
        self.dir = "r"
        self.delimiter = 200

    # move koishi downwards if not on a platform
    def gravity(self, assets):
        if self.platform is None:
            self.jumpboost = 1
            self.rect.y += self.yvel
            self.yvel += 0.18
            if self.yvel >= 15:  # terminal velocity
                self.yvel = 15

        if self.rect.top >= 600:
            play_sound(assets.dieSound)
            self.dead = "fall"

    # set vertical speed to positive if jumping
    def jump(self):
        if self.platform is not None:
            self.yvel = -7 * self.jumpboost
            self.platform = None
        self.jumpboost = 1

    # flick through animation frames
    def animate(self):
        self.imCounter += 0.15
        try:
            self.image = self.images[round(self.imCounter)]
        except IndexError:
            self.imCounter = -0.15
            self.image = self.images[round(self.imCounter)]

    def update(self, display, assets):
        keys = pygame.key.get_pressed()

        # left movement, providing not at left edge
        if keys[pygame.K_LEFT] and self.delimiter > 0:
            self.dir = "l"
            self.delimiter -= 4
            for sprite in self.groups.moveableSprites:
                sprite.rect.x += 4
                # if a sprite needs to do anything other than move when the player moves
                # example, a bullet's target also needs to move
                try:
                    sprite.shift(4)
                except AttributeError:
                    pass
            self.images = self.limages
        # right movement
        elif keys[pygame.K_RIGHT]:
            self.dir = "r"
            self.delimiter += 4
            for sprite in self.groups.moveableSprites:
                sprite.rect.x -= 4
                try:
                    sprite.shift(-4)
                except AttributeError:
                    pass  # just ignore stuff that doesn't have a shift
            self.images = self.rimages
        else:
            self.images = self.fimages

        if keys[pygame.K_SPACE]:
            self.jump()

        # attempt to fire
        if keys[pygame.K_f]:
            if self.fireCountdown <= 0:
                KoishiBullet(self.groups, assets)
                self.fireCountdown = 10
        if self.fireCountdown >= 0:
            self.fireCountdown -= 1

        # generate a shield
        if keys[pygame.K_q]:
            if self.shieldCountdown <= 0:
                Shield(self.groups, assets)
                play_sound(assets.powerUpSound)
                self.shieldCountdown = 900
        if self.shieldCountdown >= 0:
            self.shieldCountdown -= 1

        # display an indicator to the player that jump boost is active
        if self.jumpboost != 1:
            display.blit(assets.blueDiamond, (self.rect.centerx - 10, self.rect.top - 20))
            if self.platform is None:
                self.jumpboost = 1
        self.gravity(assets)
        self.animate()


# base class. for a basic, stationary enemy
# imdirectory specifies a folder containing the sprite's animation frames
class BaseEnemy(pygame.sprite.Sprite):
    def __init__(self, groups, x, y, imdirectory, hp=5, func=do_nothing, rate=0.1):
        pygame.sprite.Sprite.__init__(self)
        self.groups = groups
        self.images = []
        self.hp = hp
        self.func = func
        # is updated every frame, controls activation of actions
        self.counter = 0

        # imCounter is updated by rate every frame
        # tracks current animation frame
        self.rate = rate
        self.imCounter = float(0)

        # extracts the images from imdirectory
        self.n = 0
        while True:
            try:
                self.images.append(load_image(f"{imdirectory}{self.n}.png"))
                self.n += 1
            except FileNotFoundError:
                self.image = self.images[0]
                break

        self.rect = self.image.get_rect()
        self.rect.midbottom = (x, y)
        self.add(groups.allSprites, groups.moveableSprites, groups.enemies)

    def animate(self):
        try:
            self.image = self.images[round(self.imCounter)]
        except IndexError:
            self.imCounter = 0
            self.image = self.images[round(self.imCounter)]

    # runs every frame
    def update(self, assets):
        self.func(self, assets)
        self.counter = round(self.counter+1)
        self.imCounter = self.imCounter + self.rate

        if self.hp <= 0:
            play_sound(assets.enemyDieSound)
            self.kill()

        self.animate()


# an enemy that is treated as a boss
class Boss(BaseEnemy):
    def __init__(self, groups, x, y, directory, name, hp):
        BaseEnemy.__init__(self, groups, x, y, f"media/enemies/{directory}/", hp=hp)
        self.fimages = [self.images[0]]
        self.maxhp = hp
        self.limages = self.images[1:]
        self.rimages = [pygame.transform.flip(im, True, False) for im in self.limages]
        self.dir = "n"
        self.mspeed = 0
        self.origin = self.rect.centerx
        self.name = name
        self.groups = groups
        self.add(groups.bossSprites)
        self.targetx = self.rect.centerx

    def shift(self, amount):
        self.targetx += amount
        self.origin += amount

    def move_towards_target(self):
        dx = self.targetx - self.rect.centerx
        if dx >= self.mspeed:
            self.rect.centerx += self.mspeed
            self.images = self.rimages
        elif dx <= - self.mspeed:
            self.rect.centerx -= self.mspeed
            self.images = self.limages
        else:
            self.images = self.fimages

    def display_hp(self, display):
        draw_text(display, self.name, 890, 10, align="topright")
        pygame.draw.rect(display, (255, 255, 255), [515, 35, 370, 20], 5)
        pygame.draw.rect(display, (255, 0, 0), [520, 40, 360 * (self.hp / self.maxhp), 10])


# stage 4 boss
class Satori(Boss):
    def __init__(self, groups):
        Boss.__init__(self, groups, 1400, 330, "satori", "Satori Komeiji", hp=70)
        self.mspeed = 1
        self.icon = load_image("media/characters/satori.png")
        self.dialogue = [
            [1, "You did well"],
            [0, "Of course! Off I go then, see you later"],
            [1, "Be back by night time"]
        ]

    def update(self, assets):
        self.counter = round(self.counter+1)
        self.imCounter = self.imCounter + self.rate
        self.move_towards_target()
        self.animate()

        if self.counter == 2 or self.counter == 420:
            play_sound(assets.attack1)
            attacks.fire_circle(self.groups, self.rect.centerx, self.rect.centery,
                                7, 2, assets.pinkCircle, accel=0,
                                offset=random.randint(0, 360))

        if self.counter == 660:
            play_sound(assets.warn)

        if self.counter == 690 or self.counter == 720:
            attacks.fire_circle(self.groups, self.rect.centerx, self.rect.centery,
                                40, 2, assets.pinkCircle, offset=0)
        if self.counter == 705:
            attacks.fire_circle(self.groups, self.rect.centerx, self.rect.centery,
                                40, 2, assets.blueCircle, offset=360 / 80)

        if self.counter == 20:
            self.targetx = self.origin - 400

        if self.counter == 440:
            self.targetx = self.origin - 200

        if self.counter == 730:
            self.targetx = self.origin

        if self.counter % 50 == 0:
            play_sound(assets.attack3, volume=0.5)
            attacks.fire_at_player(self.groups, self.rect.centerx, self.rect.centery,
                                   2, assets.greenCircle)

        if self.counter >= 930:
            self.counter = 0


# stage 8 boss
class Kisume(Boss):
    def __init__(self, groups):
        Boss.__init__(self, groups, 900, 330, "kisume", "Kisume", hp=30)
        self.mspeed = 1
        self.down = False
        self.counter = 180
        self.icon = load_image("media/characters/kisume.png")
        self.dialogue = [
            [1, "Agh, you're good"],
            [0, "That was fun. See you on my way back then!"],
            [1, "Your... w- way back?"]
        ]
        self.targetx = self.rect.centerx

    def update(self, assets):
        self.counter = round(self.counter+1)
        self.imCounter = self.imCounter + self.rate
        self.move_towards_target()
        self.animate()
        if (not self.down) and (self.rect.bottom > 200) and self.counter >= 180:
            self.rect.y -= 10
        elif self.down and self.rect.bottom < 570 and self.counter >= 60:
            self.rect.y += 10

        if self.rect.left < self.groups.koishi.sprite.rect.centerx < self.rect.right and not self.down:
            self.down = True
            self.counter = 0
            self.targetx = self.rect.centerx
        elif not self.down and self.counter >= 180:
            self.targetx = self.groups.koishi.sprite.rect.centerx

        if self.counter % 20 == 0:
            attacks.fire_circle(self.groups, self.rect.centerx, self.rect.centery, 1, 4,
                                assets.greenCircle, offset=random.randint(-120, -60),
                                gravity=0.1 + 0.001 * random.randint(-20, 20))

        if self.counter == 99:
            for direction in range(-120, -60, 5):
                attacks.fire_circle(self.groups, self.rect.centerx,
                                    600, 1, 10, assets.redCircle, gravity=0.1 + 0.001 * random.randint(-20, 20),
                                    offset=direction + random.randint(-1, 1))
                attacks.fire_circle(self.groups, self.rect.centerx,
                                    600, 1, 8, assets.redCircle, gravity=0.1 + 0.001 * random.randint(-20, 20),
                                    offset=direction + random.randint(-1, 1))
                attacks.fire_circle(self.groups, self.rect.centerx,
                                    600, 1, 6, assets.redCircle, gravity=0.1 + 0.001 * random.randint(-20, 20),
                                    offset=direction + random.randint(-1, 1))

        if self.counter == 150:
            self.down = False


# an enemy that walks around on a single platform
class PatrollingEnemy(BaseEnemy):
    def __init__(self, groups, x, y, imdirectory, platform, speed, hp=5, func=do_nothing):
        BaseEnemy.__init__(self, groups, x, y, imdirectory, hp=hp, func=func)
        self.limages = self.images
        self.rimages = [pygame.transform.flip(im, True, False) for im in self.limages]
        self.image = self.limages[0]
        self.rect = self.image.get_rect()
        self.platform = platform
        self.rect.midbottom = self.platform.rect.midtop
        self.speed = speed

    def update(self, assets):
        self.func(self, assets)
        self.counter = round(self.counter + 1)
        self.imCounter = self.imCounter + self.rate

        if self.hp <= 0:
            play_sound(assets.enemyDieSound)
            self.kill()

        self.rect.centerx += self.speed
        if self.rect.left < self.platform.rect.left:
            self.speed = -self.speed
            self.images = self.rimages
        elif self.rect.right > self.platform.rect.right:
            self.speed = - self.speed
            self.images = self.limages

        self.animate()


# an object the player can stand on
class Platform(pygame.sprite.Sprite):
    def __init__(self, groups, x, y, image):
        pygame.sprite.Sprite.__init__(self)
        self.image = image
        self.groups = groups
        self.rect = self.image.get_rect()
        self.rect.topleft = (x, y)

        self.add(groups.allSprites, groups.platforms, groups.moveableSprites)

    def update(self, *args):
        pass


# an object the player will phase through, taking priority
# over any incident platforms
class Gap(pygame.sprite.Sprite):
    def __init__(self, groups, x, image):
        pygame.sprite.Sprite.__init__(self)
        self.groups = groups
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.topleft = (x, 570)
        self.add(groups.allSprites, groups.gaps, groups.moveableSprites)

    def update(self):
        pass


# a platform that lowers when stepped on, or the player
# can phase through (if gap is True).
class DroppingPlatform(Platform):
    def __init__(self, groups, x, y, speed, image):
        Platform.__init__(self, groups, x, y, image)
        self.originalHeight = self.rect.top
        self.speed = speed

    def update(self):
        if self.groups.koishi.sprite.platform == self:
            self.rect.y += self.speed
            self.groups.koishi.sprite.rect.y += self.speed
        elif self.rect.top > self.originalHeight:
            if self.groups.koishi.sprite.rect.right < self.rect.left - 60 or self.groups.koishi.sprite.rect.left > self.rect.right + 60 or self.groups.koishi.sprite.rect.bottom > self.rect.bottom:
                self.rect.y -= self.speed


# miscellaneous items that do something upon
# the player touching them
class Item(pygame.sprite.Sprite):
    def __init__(self, groups, x, y, image):
        pygame.sprite.Sprite.__init__(self)
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.midbottom = (x, y)
        self.groups = groups
        self.add(groups.allSprites, groups.moveableSprites)

    def do_thing(self, assets):
        pass

    def update(self, assets):
        if pygame.sprite.spritecollide(self, self.groups.koishi, False):
            self.do_thing(assets)


# coins that progress the level
class Coin(Item):
    def __init__(self, groups, assets, x, y):
        Item.__init__(self, groups, x, y, assets.coin)
        self.add(groups.items)

    def do_thing(self, assets):
        self.groups.koishi.sprite.score += 1
        play_sound(assets.coinCollectSound)
        if self.groups.koishi.sprite.score >= self.groups.coins:
            for item in self.groups.moveableSprites:
                if isinstance(item, LevelEnd):
                    item.add(self.groups.items)
        self.kill()


# is added to groups when all coins collected
# ends the level once touched
class LevelEnd(Item):
    def __init__(self, groups, assets, x, y):
        Item.__init__(self, groups, x, y, assets.flag)

    def do_thing(self, assets):
        play_sound(assets.endSound)
        self.groups.koishi.sprite.dead = "end" + str(self.groups.level)


# sets koishi.jumpboost to power when collected
class JumpBoost(Item):
    def __init__(self, groups, assets, x, y, power):
        Item.__init__(self, groups, x, y, assets.blueDiamondFull)
        self.power = power
        self.add(groups.items)

    def do_thing(self, assets):
        if self.groups.koishi.sprite.jumpboost == 1 and self.groups.koishi.sprite.platform is not None:
            play_sound(assets.powerUpSound)
            self.groups.koishi.sprite.jumpboost = self.power


# restores koishi's HP
class Health(Item):
    def __init__(self, groups, assets, x, y):
        Item.__init__(self, groups, x, y, assets.greenDiamond)
        self.add(groups.items)

    def do_thing(self, assets):
        if self.groups.koishi.sprite.hp < 6:
            self.groups.koishi.sprite.hp = 6
            play_sound(assets.powerUpSound)
            self.kill()


# removes a gap when collected
class Deleter(Item):
    def __init__(self, groups, assets, x, y, gap):
        Item.__init__(self, groups, x, y, assets.greenDiamond)
        self.gap = gap
        self.add(groups.items)

    def do_thing(self, assets):
        play_sound(assets.powerUpSound)
        self.gap.kill()
        self.kill()


# opens a separate game loop allowing the player to click through dialogue whilst
# halting updates of all other sprites
def run_dialogue(groups, clock, display, assets, update_stats, dialogue, icon):
    box = load_image("media/bg/dialogue.png")
    count = 0

    # enter a separate game loop while the dialogue goes on
    while count < len(dialogue):
        clock.tick(30)

        display.blit(groups.bgi, (-(groups.koishi.sprite.delimiter - 200) / 10, 0))

        # draw everything in order, but do not update
        groups.onScreenAll.draw(display)
        groups.onScreenGaps.draw(display)
        groups.koishi.draw(display)
        groups.koishiBullets.draw(display)
        update_stats(groups)

        display.blit(box, (162, 400))

        text = dialogue[count][1]

        if dialogue[count][0] == 0:
            image = assets.koishiIcon
        else:
            image = icon

        display.blit(image, (182, 420))
        n = 0
        for line in split(text, 40):
            draw_text(display, line, 190 + image.get_rect().width, 420 + n)
            n += 20

        pygame.display.update()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
            elif event.type == pygame.KEYDOWN:
                if event.key in [pygame.K_SPACE, pygame.K_z, pygame.K_c]:
                    count += 1

    display.blit(groups.bgi, (-(groups.koishi.sprite.delimiter - 200) / 10, 0))

    # draw everything in order, but do not update them
    groups.onScreenAll.draw(display)
    groups.onScreenGaps.draw(display)
    groups.koishi.draw(display)
    groups.koishiBullets.draw(display)
    update_stats(groups)
    pygame.display.update()


# an NPC who you can talk to with space
class Friendly(pygame.sprite.Sprite):
    def __init__(self, groups, x, y, name, dialogue):
        pygame.sprite.Sprite.__init__(self)
        self.groups = groups
        self.image = load_image("media/characters/" + name + ".png")
        self.rect = self.image.get_rect()
        self.rect.midbottom = (x, y)
        self.dialogue = dialogue
        self.icon = load_image("media/icons/" + name + ".png")
        self.add(groups.friendlies, groups.allSprites, groups.moveableSprites)

    def update(self, events, clock, display, assets, update_stats):
        if pygame.sprite.spritecollide(self, self.groups.koishi, False):
            for event in events:
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        run_dialogue(self.groups, clock, display, assets, update_stats, self.dialogue, self.icon)
